<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>North of Visibility — Canopus Threshold</title>
  <style>
    :root{
      --bg:#050607;
      --fg:rgba(255,255,255,.78);
      --muted:rgba(255,255,255,.45);
      --line:rgba(255,255,255,.12);
      --panel:rgba(10,12,14,.78);
      --panel2:rgba(10,12,14,.92);
    }
    html,body{height:100%; margin:0; background:var(--bg); overflow:hidden; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}
    canvas{display:block; width:100vw; height:100vh;}
    .centerPrompt{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      padding:18px;
      background: radial-gradient(900px 600px at 50% 40%, rgba(0,0,0,.55), rgba(0,0,0,.85));
      z-index:10;
    }
    .card{
      width:min(520px, 100%);
      border:1px solid var(--line);
      background:linear-gradient(180deg, var(--panel), var(--panel2));
      border-radius:18px;
      padding:16px 16px 14px;
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
      color:var(--fg);
    }
    .title{font-size:14px; letter-spacing:.3px; margin:0 0 8px 0;}
    .desc{font-size:12px; line-height:1.55; color:var(--muted); margin:0 0 12px 0;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
    button{
      appearance:none; border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--fg);
      border-radius:12px;
      padding:10px 12px;
      font-size:12px;
      cursor:pointer;
    }
    button:hover{background:rgba(255,255,255,.09);}
    .tiny{font-size:11px; color:var(--muted);}
    .ui{
      position:fixed;
      left:14px; right:14px; bottom:12px;
      display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;
      z-index:5;
      pointer-events:none;
    }
    .panel{
      pointer-events:auto;
      border:1px solid var(--line);
      background:rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      border-radius:16px;
      padding:10px 12px;
      color:var(--fg);
      min-width: 230px;
    }
    .panel h3{
      font-size:11px; margin:0 0 8px 0; color:var(--muted); font-weight:600; letter-spacing:.3px;
    }
    .kv{display:grid; grid-template-columns: 1fr auto; gap:4px 10px; font-size:11px;}
    .kv div:nth-child(2n){text-align:right; color:rgba(255,255,255,.64);}
    .controls{
      display:grid; gap:8px;
      min-width: 260px;
    }
    label{font-size:11px; color:var(--muted); display:flex; justify-content:space-between; gap:10px;}
    input[type="range"]{width:100%;}
    .tog{display:flex; gap:8px; flex-wrap:wrap;}
    .chip{
      user-select:none;
      font-size:11px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      border-radius:999px;
      padding:7px 10px;
      cursor:pointer;
    }
    .chip[data-on="1"]{background:rgba(255,255,255,.12);}
    a{color:var(--fg);}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <!-- Center permission prompt -->
  <div class="centerPrompt" id="prompt">
    <div class="card">
      <p class="title">North of Visibility</p>
      <p class="desc">
        위치에 따라 화면의 밝기가 아주 조금 달라져요.<br>
        (대부분의 시간은 거의 변하지 않습니다.)
      </p>
      <div class="row">
        <button id="btnGeo">위치 허용하고 시작</button>
        <button id="btnNoGeo">위치 없이 시작</button>
      </div>
      <p class="tiny" style="margin:10px 0 0 0;">
        팁: 밤에, 남쪽으로 갈수록 “거의” 조금 더 보일 수 있어요.
      </p>
    </div>
  </div>

  <div class="ui">
    <div class="panel controls">
      <h3>Controls</h3>
      <div>
        <label>
          기준 민감도(거의 무력)
          <span id="sensV">0.35</span>
        </label>
        <input id="sens" type="range" min="0" max="1" step="0.01" value="0.35" />
      </div>
      <div>
        <label>
          화면 숨쉬기(미세)
          <span id="breathV">0.18</span>
        </label>
        <input id="breath" type="range" min="0" max="1" step="0.01" value="0.18" />
      </div>
      <div class="tog">
        <div class="chip" id="togDebug" data-on="0">debug</div>
        <div class="chip" id="togGyro" data-on="0">gyro 읽기</div>
        <div class="chip" id="togHardCut" data-on="1">cutoff</div>
      </div>
    </div>

    <div class="panel">
      <h3>Status</h3>
      <div class="kv" id="kv">
        <div>위치</div><div id="loc">unknown</div>
        <div>로컬시간</div><div id="time">--:--</div>
        <div>위도 점수</div><div id="latScore">--</div>
        <div>밤 점수</div><div id="nightScore">--</div>
        <div>짧은 창</div><div id="window">--</div>
        <div>출력 밝기</div><div id="outB">--</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Helpers ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp  = (a, b, t) => a + (b - a) * t;
  const smoothstep = (a, b, x) => {
    const t = clamp((x - a) / (b - a), 0, 1);
    return t * t * (3 - 2 * t);
  };
  const fmt = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : "—";

  // ---------- UI ----------
  const prompt = document.getElementById("prompt");
  const btnGeo = document.getElementById("btnGeo");
  const btnNoGeo = document.getElementById("btnNoGeo");

  const sens = document.getElementById("sens");
  const breath = document.getElementById("breath");
  const sensV = document.getElementById("sensV");
  const breathV = document.getElementById("breathV");

  const togDebug = document.getElementById("togDebug");
  const togGyro  = document.getElementById("togGyro");
  const togHardCut = document.getElementById("togHardCut");

  const elLoc = document.getElementById("loc");
  const elTime = document.getElementById("time");
  const elLatScore = document.getElementById("latScore");
  const elNightScore = document.getElementById("nightScore");
  const elWindow = document.getElementById("window");
  const elOutB = document.getElementById("outB");

  sens.addEventListener("input", () => sensV.textContent = Number(sens.value).toFixed(2));
  breath.addEventListener("input", () => breathV.textContent = Number(breath.value).toFixed(2));

  const toggleChip = (el) => {
    const on = el.dataset.on === "1" ? "0" : "1";
    el.dataset.on = on;
    return on === "1";
  };
  togDebug.addEventListener("click", () => toggleChip(togDebug));
  togGyro.addEventListener("click", async () => {
    const on = toggleChip(togGyro);
    if (on) await enableGyro();
  });
  togHardCut.addEventListener("click", () => toggleChip(togHardCut));

  // ---------- Canvas ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  let W = 0, H = 0, DPR = 1;

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // ---------- State ----------
  let lat = null, lon = null;
  let hasGeo = false;

  // gyro read-only (very lightly affects noise phase, not brightness)
  let gyroBias = 0;

  async function enableGyro(){
    try{
      // iOS needs permission
      if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function"){
        const res = await DeviceOrientationEvent.requestPermission();
        if (res !== "granted") throw new Error("permission denied");
      }
      window.addEventListener("deviceorientation", (e) => {
        // Keep it subtle: only a small bias in noise phase
        const a = (e.alpha ?? 0);
        const b = (e.beta  ?? 0);
        const g = (e.gamma ?? 0);
        gyroBias = (a + b + g) * 0.00015; // tiny
      }, {passive:true});
    }catch(err){
      togGyro.dataset.on = "0";
      console.warn("gyro disabled:", err);
    }
  }

  // ---------- “Canopus-ish” score model ----------
  // This is intentionally *not* precise astronomy.
  // It’s a conceptual model: latitude + night + rare window.
  //
  // latitudeScore: 0 in north (>=38.0), rises toward south (<=33.0).
  // nightScore: 0 at midday, 1 at deep night.
  // windowScore: a short 2-minute window per day (fixed by date seed).
  //
  function latitudeScore(phi){
    // Map 33°..38° to 1..0 (clamped)
    return clamp((38.0 - phi) / (38.0 - 33.0), 0, 1);
  }
  function nightScore(date){
    const h = date.getHours() + date.getMinutes()/60 + date.getSeconds()/3600;
    // Night peak around 02:00, low around 14:00
    // Use cosine to get smooth day/night cycle
    const peak = 2.0;
    const phase = (h - peak) / 24 * Math.PI * 2;
    // cosine: 1 at peak, -1 at opposite; remap to 0..1 then sharpen
    const raw = (Math.cos(phase) + 1) * 0.5;
    return smoothstep(0.2, 0.9, raw); // make day flatter
  }
  function dailyWindowScore(date){
    // Deterministic “rare window”: 2 minutes each day, centered at a pseudo-random minute near 02:xx
    const y = date.getFullYear();
    const m = date.getMonth()+1;
    const d = date.getDate();

    // simple hash
    let seed = (y*73856093) ^ (m*19349663) ^ (d*83492791);
    seed = (seed >>> 0);
    const r = (seed % 1000) / 1000; // 0..1
    const centerMinute = Math.floor( (2*60 + 10) + r * 70 ); // 02:10 ~ 03:20

    const nowMin = date.getHours()*60 + date.getMinutes() + date.getSeconds()/60;
    const dist = Math.abs(nowMin - centerMinute);

    const windowHalf = 1.0; // 2 minutes total
    const score = clamp(1 - dist / windowHalf, 0, 1);
    return { score, centerMinute };
  }

  // brightness mapping: keep “almost nothing”
  function outputBrightness(phi, date){
    const sLat = (phi == null) ? 0.35 : latitudeScore(phi);
    const sNight = nightScore(date);
    const { score: sWin, centerMinute } = dailyWindowScore(date);

    // base: 0.9% ~ 1.4%
    let base = lerp(0.009, 0.014, 0.35 + 0.65*sLat);

    // add night influence slightly
    base += 0.0022 * sNight;

    // rare window bump: max +0.005 (still tiny)
    base += 0.005 * sWin;

    // apply “cutoff”: push everything toward near-zero if latitude too north
    if (togHardCut.dataset.on === "1"){
      // north of ~37.8 becomes harshly suppressed
      const cutoff = (phi == null) ? 0.3 : clamp((37.8 - phi)/1.2, 0, 1); // <=0 when north
      const gate = smoothstep(0.0, 1.0, cutoff);
      base *= lerp(0.18, 1.0, gate);
    }

    // user "sensitivity" slider barely changes anything (by design)
    const k = Number(sens.value);
    base *= lerp(0.9, 1.08, k);

    // clamp to sane tiny range
    base = clamp(base, 0.004, 0.03);

    return { b: base, sLat, sNight, sWin, centerMinute };
  }

  // ---------- Rendering ----------
  function draw(t){
    const time = performance.now() * 0.001;
    const now = new Date();

    const { b, sLat, sNight, sWin, centerMinute } = outputBrightness(lat, now);

    // background
    const bg = 6; // almost black
    ctx.fillStyle = `rgb(${bg},${bg},${bg})`;
    ctx.fillRect(0,0,W,H);

    // “breathing” very small
    const breathAmt = Number(breath.value);
    const breathing = 1 + Math.sin(time * 0.7 + gyroBias*1000) * 0.06 * breathAmt;

    // compute luminance as near-black gray
    const lum = clamp(b * breathing, 0, 0.08); // 0..~8%
    const g = Math.floor(lerp(6, 255, lum));   // map to display gray

    // soft vignette glow (no "star")
    const cx = W*0.5, cy = H*0.47;
    const rad = Math.max(W,H) * 0.65;
    const grad = ctx.createRadialGradient(cx, cy, rad*0.05, cx, cy, rad);
    grad.addColorStop(0.0, `rgb(${g},${g},${g})`);
    grad.addColorStop(0.45, `rgb(${Math.floor(lerp(6,g,0.55))},${Math.floor(lerp(6,g,0.55))},${Math.floor(lerp(6,g,0.55))})`);
    grad.addColorStop(1.0, `rgb(6,6,6)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,W,H);

    // micro noise to create “is it changing?” feeling
    const nStrength = 0.06 + 0.18 * breathAmt;
    ctx.globalAlpha = nStrength;
    ctx.fillStyle = `rgba(255,255,255,0.03)`;
    const step = Math.floor(6 * DPR);
    for(let y=0; y<H; y+=step){
      // noise line
      const x = (Math.sin(y*0.03 + time*0.8 + gyroBias*200) + 1) * 0.5 * W;
      ctx.fillRect(x, y, step, step);
    }
    ctx.globalAlpha = 1;

    // Status display
    elTime.textContent = now.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    elLatScore.textContent = fmt(sLat, 2);
    elNightScore.textContent = fmt(sNight, 2);
    elWindow.textContent = fmt(sWin, 2) + ` (≈${String(Math.floor(centerMinute/60)).padStart(2,"0")}:${String(centerMinute%60).padStart(2,"0")})`;
    elOutB.textContent = (b*100).toFixed(2) + "%";

    const dbgOn = togDebug.dataset.on === "1";
    document.getElementById("kv").style.opacity = dbgOn ? "1" : "0.18";

    requestAnimationFrame(draw);
  }

  // ---------- Geolocation ----------
  async function requestGeo(){
    if (!("geolocation" in navigator)) throw new Error("no geolocation");
    return new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(
        pos => resolve(pos),
        err => reject(err),
        { enableHighAccuracy:false, timeout:8000, maximumAge: 1000 * 60 * 10 }
      );
    });
  }

  btnGeo.addEventListener("click", async () => {
    try{
      const pos = await requestGeo();
      lat = pos.coords.latitude;
      lon = pos.coords.longitude;
      hasGeo = true;
      elLoc.textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
      prompt.style.display = "none";
    }catch(e){
      hasGeo = false;
      elLoc.textContent = "permission denied";
      prompt.style.display = "none";
    }
  });

  btnNoGeo.addEventListener("click", () => {
    // Default: Seoul-ish
    lat = 37.5665;
    lon = 126.9780;
    hasGeo = false;
    elLoc.textContent = "fallback: seoul";
    prompt.style.display = "none";
  });

  // Start loop immediately (prompt covers it)
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
